use image::{GenericImageView, Pixel};
use std::error::Error;

pub const MAX_IMAGE_WIDTH: u32 = 0x136; // 310
pub const MAX_IMAGE_HEIGHT: u32 = 0x191; // 401

pub fn convert_img_to_c2p(image_path: &str, destination: String) -> Result<(), Box<dyn Error>> {
    let image = image::ImageReader::open(image_path)
        .expect("failed to open image!")
        .decode()
        .expect("Failed to decode image!");
    let (width, height): (u32, u32) = (image.width(), image.height());

    assert!(width > 0 && height > 0);
    let image = if width > MAX_IMAGE_WIDTH || height > MAX_IMAGE_HEIGHT {
        eprintln!("image too big! scaling down...");
        let (new_width, new_height) = (
            width / (width / MAX_IMAGE_WIDTH),
            height / (height / MAX_IMAGE_HEIGHT),
        );
        image.resize(new_width, new_height, image::imageops::FilterType::Lanczos3)
    } else {
        image
    };

    let img_data = bitmap_to_rgb565_data(image.clone());
    let compressed_img_data = compress(img_data);

    let header = &get_header(
        compressed_img_data.len(),
        image.width() as usize,
        image.height() as usize,
    );

    let footer = &get_footer();

    let mut new_file = Vec::new();
    new_file.extend_from_slice(header);
    new_file.extend_from_slice(&compressed_img_data);
    new_file.extend_from_slice(footer);

    std::fs::write(destination, new_file)?;

    Ok(())
}

fn bitmap_to_rgb565_data(image: image::DynamicImage) -> Vec<u8> {
    let mut image_data = Vec::new();

    for y in 0..image.height() {
        for x in 0..image.width() {
            let c = image.get_pixel(x, y).to_rgb().0;

            let (r, g, b) = (
                convert_range(0, 255, 0, 0x1F, c[0] as usize),
                convert_range(0, 255, 0, 0x3F, c[1] as usize),
                convert_range(0, 255, 0, 0x1F, c[2] as usize),
            );

            let rgb565: usize = (r << 11) + (g << 5) + b;
            let rgb565_2: u8 = (rgb565 >> 8 & 0xFF) as u8;
            let rgb565_1: u8 = (rgb565 & 0xFF) as u8;

            image_data.push(rgb565_2);
            image_data.push(rgb565_1);
        }
    }
    image_data
}

fn convert_range(
    original_start: usize,
    original_end: usize,
    new_start: usize,
    new_end: usize,
    value: usize,
) -> usize {
    let scale: f64 = (new_end - new_start) as f64 / (original_end - original_start) as f64;
    (new_start as f64 + ((value - original_start) as f64 * scale)) as usize
}

fn compress(input: Vec<u8>) -> Vec<u8> {
    use miniz_oxide::deflate::compress_to_vec_zlib;
    compress_to_vec_zlib(&input, 6)
}

fn get_header(image_data_size: usize, width: usize, height: usize) -> Vec<u8> {
    let file_size: usize = image_data_size + 0xDC + 0x17C; // image size + header size + footer size
    let a = !(file_size & 0xFFFFFF) & 0xFFFFFF;
    let a3 = (a >> 16 & 0xFF) as u8;
    let a2 = (a >> 8 & 0xFF) as u8;
    let a1 = (a & 0xFF) as u8;

    let b1 = ((0x1D1 - (file_size & 0xFF)) & 0xFF) as u8;

    let c = file_size - 0x20;
    let c4 = (c >> 24 & 0xFF) as u8;
    let c3 = (c >> 16 & 0xFF) as u8;
    let c2 = (c >> 8 & 0xFF) as u8;
    let c1 = (c & 0xFF) as u8;

    let d = file_size - 0x234;
    let d4 = (d >> 24 & 0xFF) as u8;
    let d3 = (d >> 16 & 0xFF) as u8;
    let d2 = (d >> 8 & 0xFF) as u8;
    let d1 = (d & 0xFF) as u8;

    let e = file_size - 0x254;
    let e4 = (e >> 24 & 0xFF) as u8;
    let e3 = (e >> 16 & 0xFF) as u8;
    let e2 = (e >> 8 & 0xFF) as u8;
    let e1 = (e & 0xFF) as u8;

    let w = width & 0xFFFF;
    let h = height & 0xFFFF;
    let w2 = (w >> 8 & 0xFF) as u8;
    let w1 = (w & 0xFF) as u8;
    let h2 = (h >> 8 & 0xFF) as u8;
    let h1 = (h & 0xFF) as u8;

    let f = file_size - 0x258;
    let f4 = (f >> 24 & 0xFF) as u8;
    let f3 = (f >> 16 & 0xFF) as u8;
    let f2 = (f >> 8 & 0xFF) as u8;
    let f1 = (f & 0xFF) as u8;

    return vec![
        0xBC, 0xBE, 0xAC, 0xB6, 0xB0, 0xFF, 0xFF, 0xFF, 0x9C, 0xCD, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0xFE, 0xFF, a3, a2, a1, b1, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x43, 0x43, 0x30, 0x31, 0x30, 0x30, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x43, 0x50, 0x00,
        0x00, 0x00, c4, c3, c2, c1, 0x00, 0x00, 0x00, 0x09, d4, d3, d2, d1, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x30, 0x31, 0x30, 0x30, e4, e3, e2, e1, 0x00, 0x00, w2, w1, h2, h1, 0x00, 0x10, 0x00, 0xFF,
        0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, f4, f3,
        f2, f1,
    ];
}

fn get_footer() -> Vec<u8> {
    return vec![
        0x30, 0x31, 0x30, 0x30, 0x00, 0x00, 0x00, 0x8C, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x60, 0x00, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x04, 0x60, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x28, 0x31, 0x85,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 0x28, 0x32, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x31,
        0x30, 0x30, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x50, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
        0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x00, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
        0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    ];
}
